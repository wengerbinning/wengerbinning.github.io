# 虚拟文件系统

VFS是内核子系统，为用户空间程序提供文件和文件系统相关的接口。系统中所有的文件系统不仅都依赖于
VFS，而且也依靠VFS系统协同工作；通过VFS，用户可以基于系统调用来实现不同文件系统之间操作。

VFS提供一个通用的文件系统模型，囊括了文件系统上基本的功能集和行为，需要说明的一点是，该模型更
偏向于UNIX风格的文件系统。实际文件系统只需提供该模型中期望的抽象接口和数据结构，即可以通过该
模型来访问实际文件系统。

## UNIX文件系统

UNIX文件系统存在四种和文件系统相关抽象概念：文件、目录项、索引结点、挂载点。从本质上讲，文件
系统是特殊的数据分层存储结构，包含文件、目录与相关的控制信息，文件系统的通用操作是创建、删除、
挂载等；在UNIX中，文件系统被挂载一个挂载点上，该挂载点在全局层次结构中被称作命名空间。所有的
文件系统都挂载在根文件系中。与之相反的是Windows对文件系统的处理：将文件的命名空间分类为驱动
字母，例如C盘。

在上文提到的四个概念中，文件可以等效为一个有序的字符串，文件头部即字符串的开始，文件的结尾即
字符串的结尾，文件的基本操作有创建、删除、读、写等；文件通过目录组织起来，即文件夹，目录可以
嵌套形成路径，路径中的每一部分被成为目录条目，统称为目录项，在UNIX中，目录属于普通文件，可以
执行文件操作，这里需要说明一点：目录项本质是为遍历目录的数据接口，而目录实质是一个普通的文件，
所以两者是有区别的；UNIX系统将文件的相关信息与文件内容加以区分，例如访问控制权限、大小、拥有
者、创 建时间等文件相关信息，被称作文件的元数据，这些信息存储在一个单独的数据结构中，该数据结
构为索引结点，该数据结构在实际的文件系统中存储在超级块，超级块是一种包含文件系统信息的数据结
构；UNIX文件系统在物理磁盘上的布局与上面结构相同。如FAT、NTFS等不同风格的文件系统需要经过封
装后才能在Linux上工作。

VFS在实际实现时采用的面向对象的设计思路，使用C语言的struct来实现数据结构的抽象，其数据结构有
`super_block`、`inode`、`dentry`、`file`四个。

**struct super_block**
 
* 各类文件系统必须实现超级块对象，用于存储特定的文件系统信息，通常对应于存放在磁盘特定扇区中的
文件系统超级快或文件系统控制块，对于并非基于磁盘的文件系统，会在使用现场创建的超级块该数据结
构定义在`linux/fs.h`中。 创建、管理与撤销超级块的操作都定义在`fs/super.c`中，通过
`alloc_super`来实现创建并初始化对象。在安装文件系统时会调用该函数来生成对应的文件系统的对象。

**struct inode**

* 索引结点包含了内核在操作文件或目录是需要的全部信息，对与UNIX风格的文件系统来说，这些信息可以
从磁盘中直接读入，如果那个件系统没有索引结点，需要提取这些信息，在内存中创建索引结点，在文件
被访问时，在内存中创建结点，代表一个文件

**struct dentry**

* 目录项是VFS引入的为方便查找操作，在路径中所有的目录对被当作目录项。VFS在执行目录操作时，会创
建目录项对象。目录项有三种状态：被使用、未被使用以及负状态。目录项一般被缓存在目录项缓存中。


**struct file**

* file是描述进程已经打开的文件，包含访问模式、当前偏移等信息。该对象由open创建，close销毁。

以上的数据类型需要包含相应的操作，这些操作包含在以下的接口中，因为C语言不提供面向对象的机制，
但是通过函数指针同样也可以实现类似的效果。


**super_operations**

**inode_operations**

**dentry_operation**

**file_operations**

除了以上基本的数据结构之外，还需要一部分数据结构来存储挂载点等信息。

**struct file_system_type**

* file_system_type用来描述各种特定的文件系统类型，例如ext3、ext4等。

**struct vfsmount**

* vfsmount用于描述挂载点的信息，

**struct file_struct**

* file_struct用于描述进程已打开的文件，

**struct fs_struct**

fs_struct包含文件系统和进程相关的信息，

**struct mmt_namespace**



-----------


每一个文件系统都是由file_system_type结构体来表示，描述文件系统及其性能；
每一个挂载点由一个vfsmount结构体来表示。


------
