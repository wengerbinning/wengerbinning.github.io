中断可以分为上半部与下半部，在下半部的实现中有软中断、tasklet与工作队列三种，在v2.6之前的内核
版本还有bottom half与任务队列，这个两种实现在v2.6中移除。只剩下3种实现。


在softirq、tasklet以及workqueue的选择时，可以根据以下条件来判断：

* 下半部的任务需要睡眠， 选择workqueue；
* 下半部的任务需要延时指定时间再触发，选择workqueue（利用timer延时）；
* 下半部的任务需要再tick之内完成，选择softirq或者tasklet；
* 下半部的任务对延时没有要求，使用工作队列；



中断服务程序一般都是在中断请求关闭的条件下执行的，以避免嵌套而使中断控制复杂化。
中断是一个异步事件，如果关中断的时间太长，CPU就不能及时响应其他中断请求，从而
造成中断丢失。

因此，为解决这个问题，Linux内核的目标就是尽可能的快处理完中断请求，尽其所能将
更多处理向后推迟；所以内核将中断处理分为两部分：上半部(top-half)与下半部(bottom-half),
上半部是中断服务程序，内核会立即执行，执行期间关闭中断；下半部是一些内核函数（
之后简称为bh函数）后续再作处理，处理期间不关闭中断。


bh函数在2.4之前，同一时刻只能由一个cpu执行，避免多cpu相互干扰，bh函数严格遵守串行化，且
不允许嵌套。在2.4+的通过软中断请求、小任务、工作队列三种机制来实现并行处理。

softirq与tasklet对BH的处理不能时间过长，workqueue与threaded irq handler两者对BH的处理的
调度依赖调度器
